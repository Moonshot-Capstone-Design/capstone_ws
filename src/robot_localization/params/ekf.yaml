### ekf config file ###
ekf_filter_node:
  ros__parameters:
    # ================================
    # 1. 필터 기본 동작 주기 및 타임아웃
    # ================================
    # [frequency]
    # - 필터가 상태 추정값(odom → base_link 변환, Odometry 메시지)을 퍼블리시하는 주기(Hz).
    # - 최소 한 번 이상의 입력 센서 메시지를 받은 뒤에야 계산을 시작한다.
    # - 그 이후에는 센서 입력이 잠시 끊기더라도, 여기서 설정한 주기로 계속 상태를 출력한다.
    # - 값이 낮으면 로봇 움직임이 끊어져 보이고, 너무 높으면 CPU 부담이 커진다.
    # - 일반적인 실내 자율주행(AGV/AMR)에서는 20~50Hz 정도가 많이 쓰인다.
    frequency: 30.0

    # [sensor_timeout]
    # - 특정 센서에서 이 시간(초) 동안 데이터가 오지 않으면, 해당 센서는 “타임아웃”으로 간주한다.
    # - 이때 필터는 보정(correction) 없이 예측(predict)만 수행한다.
    # - 즉, 센서가 잠시 끊겨도 필터가 계속 돌아가도록 하기 위한 최소 주기 개념이다.
    # - 기본값은 1 / frequency 이며, 보통 센서 주기보다 약간 큰 값(0.1~0.2초 등)을 사용한다.
    sensor_timeout: 0.1

    # ================================
    # 2. 차원/좌표계 관련 설정
    # ================================
    # [two_d_mode]
    # - false: 완전한 3D 모델 사용 (x, y, z, roll, pitch, yaw 모두 추정).
    # - true : 2D 평면 모델로 단순화 (z, roll, pitch를 무시하고 x, y, yaw만 추정).
    # - 바닥이 평평한 실내 자율주행 로봇(차륜형 AMR/AGV)의 경우 true로 두는 경우가 많다.
    # - IMU가 바닥의 작은 기울기까지 감지해 z, roll, pitch가 계속 흔들리는 문제가 있다면,
    #   two_d_mode를 true로 두면 훨씬 안정적으로 동작한다.
    two_d_mode: false

    # [transform_time_offset]
    # - 필터가 퍼블리시하는 TF(예: odom → base_link)에 시간 오프셋을 더해준다.
    # - 일부 플래너/센서 노드가 미래 시점의 transform을 요구할 때 사용할 수 있다.
    # - 대부분의 시스템에서는 0.0 그대로 사용해도 문제가 없다.
    transform_time_offset: 0.0

    # [transform_timeout]
    # - 필터가 내부적으로 TF를 요청할 때, 변환이 준비될 때까지 기다리는 최대 시간(초).
    # - TF 의존성이 복잡한 대형 시스템이 아니라면 보통 0.0 또는 매우 작은 값으로 둔다.
    transform_timeout: 0.0

    # ================================
    # 3. 디버그/진단 설정
    # ================================
    # [print_diagnostics]
    # - true로 설정하면 /diagnostics 또는 /diagnostics_agg 토픽에 필터 관련 진단 정보를 퍼블리시한다.
    # - 센서 설정, covariance 문제 등으로 인해 필터가 경고를 내는지 쉽게 확인할 수 있다.
    print_diagnostics: true

    # [debug]
    # - true로 설정하면, 내부 계산(예측/보정, 행렬 등)을 매우 자세히 파일로 출력한다.
    # - 출력량이 엄청나고 성능에 큰 악영향을 주므로, 튜닝/디버깅 일시적으로만 켜두는 것이 좋다.
    debug: false

    # [debug_out_file]
    # - debug 로그를 기록할 파일 경로.
    # - 기본값은 "robot_localization_debug.txt"지만, 실제 사용할 땐 절대 경로를 명시하는 것을 권장한다.
    #   예: /home/사용자이름/rl_ekf_debug.txt
    debug_out_file: /path/to/debug/file.txt

    # ================================
    # 4. 퍼블리시/TF 동작 제어
    # ================================
    # [permit_corrected_publication]
    # - 과거 시점의 측정값이 늦게 도착해서 현재 상태를 다시 보정해야 하는 경우,
    #   그 보정된 결과를 다시 퍼블리시할지 여부.
    # - true : 시간 순서가 조금 꼬여도, 더 정확한 추정을 위해 재퍼블리시 허용.
    # - false: TF 시간 일관성을 유지하기 위해, 보통은 false로 두는 편이 안전하다.
    permit_corrected_publication: false

    # [publish_acceleration]
    # - 상태 벡터 중 가속도(ax, ay, az)를 Odometry 등에 포함해서 퍼블리시할지 여부.
    # - 가속도가 필요한 특수한 제어/분석이 없다면 false 유지.
    publish_acceleration: false

    # [publish_tf]
    # - 필터가 world_frame(보통 odom 또는 map)에서 base_link_frame으로의 TF를 직접 퍼블리시할지 여부.
    # - 동일한 TF를 다른 노드(robot_state_publisher, 다른 EKF 등)가 퍼블리시하면 충돌이 난다.
    # - 한 시스템에서 같은 프레임 쌍(예: odom→base_link)은 한 노드만 publish해야 한다.
    publish_tf: true

    # ================================
    # 5. 프레임 구조 설정 (REP-105)
    # ================================
    # [map_frame, odom_frame, base_link_frame, world_frame]
    # - REP-105에서 정의하는 주요 프레임:
    #   - base_link: 로봇 본체에 붙어 있는 기준 프레임.
    #   - odom     : 로컬 기준 프레임. 짧은 시간 내에서는 정확하고 연속적이지만, 장기적으로 드리프트.
    #   - map      : 글로벌 기준 프레임. SLAM/AMCL/GPS 정보로 인해 이따금 점프할 수 있다.
    # - world_frame:
    #   - EKF가 “세계 좌표”로 사용하는 프레임 이름.
    #   - 연속적인 로컬 움직임(휠/IMU)를 fuse할 때는 보통 odom을 world_frame으로 둔다.
    #   - GPS/지도 기반 절대 위치를 fuse하는 EKF라면 map을 world_frame으로 쓰는 구성이 일반적이다.
    map_frame: map              # 시스템에서 사용하는 map 프레임 이름
    odom_frame: odom            # 로컬 오도메트리 프레임 이름
    base_link_frame: base_link  # 로봇 몸체 기준 프레임 이름
    world_frame: odom           # 이 EKF가 기준으로 삼는 world 프레임

    # ================================
    # 6. 센서 입력: Odom 0 (주 오도메트리)
    # ================================
    # [odom0]
    # - 첫 번째 Odometry 입력 토픽.
    # - 실제 시스템에서는 예: "/wheel/odom", "/odom" 등으로 변경.
    odom0: example/odom

    # [odom0_config]
    # - 이 센서가 어떤 상태변수를 업데이트할지 결정하는 boolean 벡터.
    # - 순서: x, y, z, roll, pitch, yaw,
    #         vx, vy, vz, vroll, vpitch, vyaw,
    #         ax, ay, az
    # - true  : 이 센서가 해당 상태를 관측하고, 필터가 그 정보를 사용해 보정한다.
    # - false : 이 센서는 해당 상태를 관측하지 않는 것으로 간주(무시).
    # - 아래 예:
    #   - x, y: true → 2D 평면 위치를 휠 오도메트리로 보정.
    #   - yaw: 마지막 항목 (vyaw)만 true → 속도 쪽에서 yaw 속도를 사용.
    odom0_config: [true,  true,  false,
                   false, false, false,
                   false, false, false,
                   false, false, true,
                   false, false, false]

    # [odom0_queue_size]
    # - 해당 토픽에 대해 ROS에서 버퍼링할 메시지 개수.
    # - 센서 주파수가 높거나, EKF 업데이트 주기가 상대적으로 느리다면 2~5로 조금 늘려주는 것이 좋다.
    odom0_queue_size: 2

    # [odom0_differential]
    # - true:
    #   - 절대 pose 데이터를 미분해서 “속도 데이터”로 변환한 뒤 필터에 주입.
    #   - 서로 다른 pose 센서 둘이 같은 축을 측정하고, covariance가 과소추정되어
    #     필터가 두 센서 사이에서 튀는 현상이 생길 때 쓰기 좋다.
    # - false:
    #   - 센서가 제공하는 pose 값을 그대로 절대 좌표로 사용.
    # - 휠오도메트리는 보통 이미 속도 적분 형태라서, 기본적으로 false로 시작하는 게 자연스럽다.
    odom0_differential: false

    # [odom0_relative]
    # - true:
    #   - 첫 측정값을 (0,0,0,...) 기준으로 삼는다.
    #   - 예: 센서가 처음에 (10, 5)에서 시작해도 EKF 내부에서는 (0,0)으로 취급.
    # - differential과 달리, pose를 속도로 변환하지 않고 단순히 기준점을 옮기는 역할.
    odom0_relative: false

    # [odom0_pose_use_child_frame]
    # - child_frame_id의 시작 pose를 오도메트리 원점으로 사용할지 여부.
    # - base_link와 고정된 다른 링크(예: “rear_axle_link”) 기준으로 오도메트리를 줄 때 사용하는 옵션.
    # - 일반적인 base_link 기준 오도메트리에서는 false 유지.
    odom0_pose_use_child_frame: false

    # [odom0_pose_rejection_threshold, odom0_twist_rejection_threshold]
    # - 마할라노비스 거리 기반 outlier 제거 threshold.
    # - pose_rejection_threshold:
    #   - 위치/자세 측정값이 현재 추정 상태와 너무 멀리 떨어져 있으면(거리 > threshold) 해당 측정값 폐기.
    # - twist_rejection_threshold:
    #   - 속도 측정값에 대한 동일 개념.
    # - 값이 작을수록 이상치에 더 민감하게 반응하고, 너무 크면 outlier도 거의 다 받아들인다.
    odom0_pose_rejection_threshold: 5.0
    odom0_twist_rejection_threshold: 1.0

    # ================================
    # 7. 센서 입력: Odom 1 (보조 오도메트리 예시)
    # ================================
    # - 필요 없으면 odom1 이하 블록은 완전히 삭제해도 된다.
    odom1: example/odom2
    odom1_config: [false, false, true,
                   false, false, false,
                   false, false, false,
                   false, false, true,
                   false, false, false]
    odom1_differential: false
    odom1_relative: true
    odom1_queue_size: 2
    odom1_pose_rejection_threshold: 2.0
    odom1_twist_rejection_threshold: 0.2

    # ================================
    # 8. 센서 입력: Pose 0 (예: SLAM/AMCL Pose)
    # ================================
    # [pose0]
    # - geometry_msgs/PoseWithCovarianceStamped 입력.
    # - Cartographer, SLAM Toolbox, AMCL 등에서 나오는 지도(map) 기준 pose를 넣을 때 사용.
    pose0: example/pose
    pose0_config: [true,  true,  false,
                   false, false, false,
                   false, false, false,
                   false, false, false,
                   false, false, false]
    # - differential:
    #   - true면 pose를 미분하여 속도로 변환 후 사용.
    #   - SLAM pose를 직접 절대 위치로 사용하는 대신, 이동 속도 정보만 쓰고 싶을 때 사용 가능.
    pose0_differential: true
    pose0_relative: false
    pose0_queue_size: 5
    pose0_rejection_threshold: 2.0  # pose 계열은 pose_rejection_threshold 이름 사용

    # ================================
    # 9. 센서 입력: Twist 0 (속도 전용 센서 예시)
    # ================================
    twist0: example/twist
    twist0_config: [false, false, false,
                    false, false, false,
                    true,  true,  true,
                    false, false, false,
                    false, false, false]
    twist0_queue_size: 3
    twist0_rejection_threshold: 2.0

    # ================================
    # 10. 센서 입력: IMU 0 (핵심 센서)
    # ================================
    # [imu0]
    # - sensor_msgs/Imu 입력.
    # - 일반적으로:
    #   - roll, pitch, yaw: true (단, yaw는 SLAM에서 더 정확하면 false로 둘 수도 있다)
    #   - 각속도(vroll, vpitch, vyaw): true
    #   - 선가속도(ax, ay, az): true (또는 상황에 따라 일부 비활성화)
    imu0: example/imu
    imu0_config: [false, false, false,
                  true,  true,  true,
                  false, false, false,
                  true,  true,  true,
                  true,  true,  true]
    imu0_differential: false
    imu0_relative: true
    imu0_queue_size: 5
    imu0_pose_rejection_threshold: 0.8                 # 자세(roll, pitch, yaw)에 대한 outlier 임계값
    imu0_twist_rejection_threshold: 0.8                # 각속도에 대한 outlier 임계값
    imu0_linear_acceleration_rejection_threshold: 0.8  # 선가속도에 대한 outlier 임계값

    # [imu0_remove_gravitational_acceleration]
    # - IMU가 중력 성분을 자동으로 제거하지 않는 경우 true로 설정.
    # - 필터 내부에서 중력을 빼기 때문에, IMU 데이터는 REP-103 ENU 좌표계(동, 북, 위)를 따라야 한다.
    imu0_remove_gravitational_acceleration: true

    # ================================
    # 11. 제어 입력(cmd_vel) 사용 설정
    # ================================
    # [use_control]
    # - true:
    #   - cmd_vel을 이용해 예측 단계에서 “로봇이 이렇게 움직일 것이다”라는 추가 정보를 사용.
    #   - 가속도 측정이 없을 때, 속도 변화를 더 잘 추적하는 데 도움이 된다.
    # - false:
    #   - 제어 입력을 사용하지 않고, 오로지 센서 측정만으로 예측/보정을 수행.
    use_control: true

    # [stamped_control]
    # - true : geometry_msgs/TwistStamped 타입을 제어 입력으로 사용.
    # - false: geometry_msgs/Twist 타입을 사용.
    # - 사용 중인 /cmd_vel 토픽 타입에 맞춰 설정해야 한다.
    stamped_control: true

    # [control_timeout]
    # - 마지막으로 받은 제어 명령을 예측에 사용할 수 있는 최대 시간(초).
    # - 이 시간이 지나면, 더 이상 그 명령을 유효한 것으로 보지 않는다.
    control_timeout: 0.2

    # [control_config]
    # - 어떤 속도 항목이 제어 입력으로 직접 제어되는지 지정.
    # - 순서: vx, vy, vz, vroll, vpitch, vyaw
    # - 일반적인 차륜형 로봇:
    #   - 전진 속도(vx)와 yaw 속도(vyaw)만 true → [true, false, false, false, false, true]
    control_config: [true, false, false, false, false, true]

    # [acceleration_limits, deceleration_limits]
    # - 로봇의 물리적 가속/감속 한계를 나타낸다.
    # - 순서: ax, ay, az, aroll, apitch, ayaw
    # - EKF가 예측 단계에서 제어 입력을 사용할 때, 이 한계를 넘지 않도록 속도 변화량을 제한한다.
    acceleration_limits: [1.3, 0.0, 0.0, 0.0, 0.0, 3.4]
    deceleration_limits: [1.3, 0.0, 0.0, 0.0, 0.0, 4.5]

    # [acceleration_gains, deceleration_gains]
    # - 최대 가속/감속까지 한 번에 점프하지 못하도록, 변화량을 부드럽게 만드는 계수.
    # - 0~1 사이 값이 일반적이며, 1.0은 “허용 범위까지 바로 사용”을 의미한다.
    acceleration_gains: [0.8, 0.0, 0.0, 0.0, 0.0, 0.9]
    deceleration_gains: [1.0, 0.0, 0.0, 0.0, 0.0, 1.0]

    # ================================
    # 12. 프로세스 노이즈 공분산 (Q 행렬)
    # ================================
    # [process_noise_covariance]
    # - 예측 단계에서 “모델 자체의 불완전함”을 반영하는 잡음 크기.
    # - 값이 클수록:
    #   → 예측이 부정확하다고 가정 → 들어오는 센서 측정을 더 신뢰.
    # - 값이 작을수록:
    #   → 모델을 매우 신뢰 → 센서의 변화를 잘 반영하지 않을 수 있다.
    # - 특정 상태가 느리게 수렴하거나, 센서값을 더 적극적으로 반영하고 싶다면
    #   해당 상태의 대각 성분을 키우는 식으로 튜닝한다.
    # - 순서: x, y, z, roll, pitch, yaw,
    #         vx, vy, vz, vroll, vpitch, vyaw,
    #         ax, ay, az
    process_noise_covariance: [0.05, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.05, 0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.06, 0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.03, 0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.03, 0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.06, 0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.025, 0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.025, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.04, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.01, 0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.01, 0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.02, 0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.01, 0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.01, 0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.015]

    # ================================
    # 13. 초기 상태 공분산 (P0 행렬)
    # ================================
    # [initial_estimate_covariance]
    # - 필터 시작 시 각 상태 변수의 초기 불확실성(분산)을 나타낸다.
    # - 값이 크면 “이 상태를 잘 모른다”고 가정 → 처음 들어오는 센서값에 빠르게 수렴.
    # - 값이 작으면 “이미 잘 알고 있다”고 가정 → 센서값이 잘 반영되지 않을 수 있다.
    # - 직접 측정되지 않는 상태(예: 항상 센서가 없는 축)의 분산을 너무 크게 두면
    #   그 축의 추정이 불필요하게 요동칠 수 있으므로 주의.
    # - 순서: x, y, z, roll, pitch, yaw,
    #         vx, vy, vz, vroll, vpitch, vyaw,
    #         ax, ay, az
    initial_estimate_covariance: [1e-9, 1e-9, 1e-9, 1e-9, 1e-9, 1e-9,
                                  1e-9, 1e-9, 1e-9, 1e-9, 1e-9, 1e-9,
                                  1e-9, 1e-9, 1e-9]
